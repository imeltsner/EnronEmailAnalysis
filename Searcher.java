import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Stack;

/**
 * Performs bfs and dfs on communication graph
 */
public class Searcher {
    //class methods
    HashMap<String, Vertex> graph;

    /**
     * Constuctor
     * @param graph graph generated by Parser
     */
    public Searcher(HashMap<String, Vertex> graph) {
        this.graph = graph;
    }

    /**
     * Finds team size using bfs algorithm
     * @param email starting point for bfs
     * @return number of teammates
     */
    public int findTeamSize(String email) {
        HashMap<String, Boolean> visited = new HashMap<>();
        int teamates = bfs(email, visited);
        return teamates;
    }

    /**
     * Implementation of bfs algorithm
     * @param email starting point
     * @param visited keeps track of visited vertices
     * @return number of teammates
     */
    private int bfs(String email, HashMap<String, Boolean> visited) {
        ArrayDeque<Vertex> q = new ArrayDeque<>();
        int teamates = 0;
        visited.put(email, true);
        q.add(graph.get(email));

        while (!q.isEmpty()) {
            Vertex v = q.remove();
            HashMap<String, Vertex> connections = v.getConnections();
            for (String e : connections.keySet()) {
                if (visited.get(e) == null) {
                    visited.put(e, true);
                    teamates++;
                    q.add(connections.get(e));
                }
            }
        }
        return teamates;
    }

    /**
     * Finds connectors in the graph
     * Prints them to stdout
     */
    public void findConnectors() {
        HashMap<String, Boolean> visited = new HashMap<>();
        String source = graph.keySet().iterator().next();
        ArrayList<String> connectors = dfs(source, visited);
    
        for (int i = 0; i < connectors.size(); i++) {
            System.out.println(connectors.get(i));
        }
    }

    /**
     * Finds connectors in graph
     * Prints them to stdout and writes them to file
     * @param fileName file to write connectors to
     * @throws IOException
     */
    public void findConnectors(String fileName) throws IOException {
        HashMap<String, Boolean> visited = new HashMap<>();
        String source = graph.keySet().iterator().next();
        FileWriter writer = new FileWriter(new File(fileName));
        ArrayList<String> connectors = dfs(source, visited);

        for (int i = 0; i < connectors.size(); i++) {
            System.out.println(connectors.get(i));
            writer.write(connectors.get(i) + "\n");
        }
        writer.close();
    }

    /**
     * Implementation of dfs algorithm
     * @param source starting point in the graph
     * @param visited keeps track of visited vertices
     * @return list of connectors
     */
    private ArrayList<String> dfs(String source, HashMap<String, Boolean> visited) {
        ArrayList<String> connectors = new ArrayList<>();
        Stack<Vertex> s = new Stack<>();
        Vertex w = null;
        int dfsNum = 0;
        Vertex start = graph.get(source);
        start.setDFSNum(dfsNum++);
        s.push(start);
        visited.put(source, true);

        while (!s.isEmpty()) {
            Vertex v = s.pop();
            //check if connector
            if (w != null) {
               if (updateNums(v, w, false)) {
                   connectors.add(v.getEmail());
               }
            }
            //search through neighbors
            HashMap<String, Vertex> connections = v.getConnections();
            for (String email : connections.keySet()) {
                if (visited.get(email) == null) {
                    visited.put(email, true);
                    w = connections.get(email);
                    w.setDFSNum(dfsNum++);
                    s.push(w);
                }
                else {
                    w = connections.get(email);
                    updateNums(v, w, true);
                }
            }
        }
        return connectors;
    }

    /**
     * Updates numbers to keep track of connectors
     * @param v vertex backed up to
     * @param w neighbor of v
     * @param visited true if w is visited, false otherwise
     * @return true if v is a connector, false otherwise
     */
    private boolean updateNums(Vertex v, Vertex w, boolean visited) {
        if (!visited) {
            if (v.getDFSNum() > w.getBack()) {
                v.setBack(Math.min(v.getBack(), w.getBack()));
            }
            else {
                return true;
            }
        }
        else {
            v.setBack(Math.min(v.getBack(), w.getDFSNum()));
        }
        return false;
    }
}
